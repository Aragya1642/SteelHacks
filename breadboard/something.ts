import { del, get, set } from "https://esm.sh/idb-keyval";
import TimeAgo from "https://esm.sh/javascript-time-ago";
import en from "https://esm.sh/javascript-time-ago/locale/en";
import { css, html, LitElement, nothing } from "https://esm.sh/lit";
import {
  customElement,
  property,
  state,
} from "https://esm.sh/lit/decorators.js";
import { unsafeHTML } from "https://esm.sh/lit/directives/unsafe-html.js";
import { until } from "https://esm.sh/lit/directives/until.js";
import MarkdownIt from "https://esm.sh/markdown-it";

TimeAgo.addDefaultLocale(en);
const timeAgo = new TimeAgo("en-US");

const markdownIt = MarkdownIt();

const eventInit = {
  bubbles: true,
  cancelable: true,
  composed: true,
};

type Message = (LLMContent | ErrorMessage) & {
  timestamp: number;
};

export type BehaviorSchema =
  /**
   * This port is deprecated and is only there because there might be graphs
   * that still use it. Don't show it in the UI unless there are existing
   * incoming wires.
   */
  | "deprecated"
  /**
   * Indicates that this particular input port value should not be cached by
   * the input bubbling machinery.
   * Use this when you'd like to continually ask the user for the same input,
   * rather that re-using cached answer (default behavior).
   */
  | "transient"
  /**
   * Indicates that the output node should bubble up to the invoking runner,
   * if any.
   * This is useful for sending outputs to the user from inside of the nested
   * graphs.
   */
  | "bubble"
  /**
   * Indicates that the input our output port is a `BoardCapability`.
   * @see [BoardCapability]
   */
  | "board"
  /**
   * Indicates that the input or output port is a `StreamCapability`.
   * @see [StreamCapability]
   */
  | "stream"
  /**
   * Indicates that the input or output port is an `ErrorCapability`.
   * @see [ErrorCapability]
   */
  | "error"
  /**
   * Indicates that the input port is usually configured, rather than wired in.
   */
  | "config"
  /**
   * Indicates that the input or output port represents base structured
   * datatype containing multi-part content of a message, generated by an LLM.
   * See [Content](https://ai.google.dev/api/rest/v1beta/Content) for details
   * on the datatype.
   */
  | "llm-content"
  /**
   * Indicates that the input or output port represents a JSON schema.
   */
  | "json-schema"
  /**
   * Indicates that the input or output port represents a JSON schema that
   * describes an input or output port.
   */
  | "ports-spec"
  /**
   * Indicates that the input or output port represents an image. The image can
   * be a URL or a base64 encoded image.
   */
  | "image"
  /**
   * Indicates that the input or output represents some sort of code
   */
  | "code"
  /**
   * Indicates that the string is a Google Drive Query. See
   * https://developers.google.com/drive/api/guides/search-files.
   */
  | "google-drive-query"
  /**
   * Indicates that the string is a Google Drive File ID.
   * https://developers.google.com/drive/api/guides/about-files#characteristics
   */
  | "google-drive-file-id";

export type Schema = {
  title?: string;
  description?: string;
  type?: string | string[];
  properties?: Record<string, Schema>;
  required?: string[];
  format?: string;
  /**
   * Can be used to provide additional hints to the UI or to other parts of
   * the system about behavior of this particular input/output or input/output
   * port.
   */
  behavior?: BehaviorSchema[];
  transient?: boolean;
  enum?: string[];
  /**
   * The default value of the schema. The UI can use this to pre-populate a
   * field with a value, if there is no `examples` present.
   */
  default?: string;
  additionalProperties?: boolean | Schema;
  items?: Schema | Schema[];
  minItems?: number;
  /**
   * Can be used by UI to pre-populate a field with a value that could be
   * used as an example.
   */
  examples?: string[];
};

export type ErrorMessage = {
  error: string;
};

export type RunBoardResultError = ["error", error: string];

export type RunBoardResultOutput = ["output", outputs: Record<string, any>];

export type RunBoardResultInput = [
  "input",
  data: {
    inputArguments: { schema: Schema };
  },
  next: string,
];

export type GraphDescriptor = {
  title: string;
  description: string;
};

export type LLMTextPart = {
  text: string;
};

export type LLMInlineDataPart = {
  inlineData: {
    data: string;
    mimeType: string;
  };
};

export type LLMPart = LLMTextPart | LLMInlineDataPart;

export type LLMContent = {
  role: string;
  parts: LLMPart[];
};

export type RunBoardResult =
  | RunBoardResultError
  | RunBoardResultOutput
  | RunBoardResultInput;

class SendMessageEvent extends Event {
  static eventName = "chatsendmessage";

  constructor(public readonly message: string) {
    super(SendMessageEvent.eventName, { ...eventInit });
  }
}

const llmContent = (text: string, role: "user" | "model") => {
  return { role, parts: [{ text }] };
};

const firstProp = (schema: Schema) => {
  return Object.entries(schema.properties)[0];
};

@customElement("chat-app")
export class ChatApp extends LitElement {
  static styles = css`
    :host {
      display: flex;
      flex-direction: column;
      height: 100%;
      width: 100%;
      max-width: 500px;
      min-width: 300px;
      border: 3px solid var(--ca-color-primary);
      border-radius: 30px;
      background-color: var(--ca-color-primary-bg);
      box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23);
      overflow: hidden;
      box-sizing: border-box;
    }

    .header {
      display: flex;
      justify-content: flex-end;
      align-items: flex-start;
      padding: 10px;
      background-color: var(--ca-color-primary);
    }

    button {
      padding: 10px 15px;
      background-color: var(--ca-color-primary);
      color: var(--ca-color-primary-bg);
      border: 2px solid var(--ca-color-primary-bg);
      border-radius: 20px;
      cursor: pointer;
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.3s cubic-bezier(.25,.8,.25,1);
      white-space: nowrap;
    }
    
    button:hover {
      background-color: #2980b9;
      box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
    }
    
    button:active {
      transform: scale(0.98);
    }

    #metadata {
      flex-grow: 1;
    }

    p, h1 {
      margin: 0;
      color: var(--ca-color-primary-bg);
      padding: 0 0.5rem 0.5rem 0.5rem;
    }

    h1 {
      font-size: 1rem;
      padding-top: 0.5rem;
      font-weight: bold;
    }

    a {
      color: #666;
      font-size: 0.75rem;
      background-color: var(--ca-color-primary-bg);
      display: inline-block;
      font-weight: normal;
      text-decoration: none;
      padding: 0 1.5rem 0 0.5rem;
      border-radius: 0.5rem;
      margin-left: 0.5rem;
      background-image: url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20height%3D%2220px%22%20viewBox%3D%220%20-960%20960%20960%22%20width%3D%2220px%22%20fill%3D%22%235f6368%22%3E%3Cpath%20d%3D%22M216-144q-29.7%200-50.85-21.15Q144-186.3%20144-216v-528q0-29.7%2021.15-50.85Q186.3-816%20216-816h264v72H216v528h528v-264h72v264q0%2029.7-21.15%2050.85Q773.7-144%20744-144H216Zm171-192-51-51%20357-357H576v-72h240v240h-72v-117L387-336Z%22%2F%3E%3C%2Fsvg%3E");
      background-repeat: no-repeat;
      background-position: right 0.5rem center;
      background-size: 0.75em 0.75em;
    }
  `;

  @property()
  accessor messages: Message[] = [];

  @property()
  accessor typing = false;

  @property()
  accessor title = "";

  @property()
  accessor description = "";

  @state()
  accessor #schema: Schema | null = null;

  #next: string | undefined;
  #url: string | null = null;

  connectedCallback() {
    super.connectedCallback();
    this.#loadMessages();
    this.#loadBoardMetadata();
  }

  async #loadBoardMetadata() {
    const board = document.querySelector("link[rel=board]") as HTMLLinkElement;
    if (board) {
      try {
        this.#url = board.href;
        const boardResponse = await fetch(board.href);
        const boardData = await boardResponse.json() as GraphDescriptor;
        this.title = boardData.title;
        this.description = boardData.description;
        document.title = boardData.title;
      } catch (e) {
        console.error("Unable to fetch board metadata", e);
      }
    }
  }

  async #loadMessages() {
    const messages = await get("messages");
    const twoDaysAgo = Date.now() - 2 * 24 * 60 * 60 * 1000;
    if (messages) {
      this.messages = (messages as Message[]).filter(
        (message) => message.timestamp > twoDaysAgo,
      );
    }
    this.#next = await get("next");
    if (!this.#next) {
      this.#startChat();
    }
    this.#schema = await get("schema");
  }

  async #saveMessages() {
    const withoutErrors = this.messages.filter((message) => {
      if ("error" in message) {
        return false;
      }
      return true;
    });
    await set("messages", withoutErrors);
    await set("next", this.#next);
    await set("schema", this.#schema);
  }

  async #clearMessages() {
    this.messages = [];
    await del("messages");
    this.#concludeChat();
    this.#startChat();
  }

  async #concludeChat() {
    this.#next = undefined;
    this.#schema = null;
    await del("schema");
    await del("next");
  }

  #addMesssage(data: LLMContent) {
    const message: Message = {
      ...data,
      timestamp: Date.now(),
    };
    this.messages = [message, ...this.messages];
  }

  #addError(data: string) {
    const message: Message = {
      error: data,
      timestamp: Date.now(),
    };
    this.messages = [message, ...this.messages];
  }

  #createBody(message: string | undefined) {
    let body;
    if (this.#next && message) {
      const [key, schema] = firstProp(this.#schema);
      const isArray = schema.type === "array";
      const content = llmContent(message, "user");
      body = {
        $next: this.#next,
        [key]: isArray ? [content] : content,
      };
    } else {
      body = {};
    }
    return JSON.stringify(body);
  }

  async #startChat() {
    this.#sendRequest();
  }

  async #sendRequest(message?: string) {
    this.typing = true;
    const response = await fetch("/", {
      method: "POST",
      body: this.#createBody(message),
    });
    await this.#processResponse(response);
    await this.#saveMessages();
    this.typing = false;
  }

  async #processResponse(response: Response) {
    let receivedNext = false;
    const text = await response.text();
    const lines = text.split("\n\n");
    for (const line of lines) {
      const trimmed = line.replace("data: ", "").trim();
      if (!trimmed) continue;
      const [type, data, next] = JSON.parse(trimmed) as RunBoardResult;
      switch (type) {
        case "input": {
          this.#next = next;
          receivedNext = true;
          const properties = data.inputArguments.schema?.properties;
          const len = Object.keys(properties || {}).length;
          if (len === 0) {
            this.#addError(
              `No properties found in schema: ${
                JSON.stringify(data.inputArguments.schema)
              }`,
            );
            break;
          } else if (len > 2) {
            this.#addError(
              `More than one property found in schema: ${
                JSON.stringify(data.inputArguments.schema)
              }`,
            );
            break;
          }
          this.#schema = data.inputArguments.schema;
          break;
        }
        case "output": {
          Object.values(data.outputs).map((port) => {
            const contentArray = (port as LLMContent[]).filter((o) =>
              o.role !== "$metadata"
            );
            const last = contentArray[contentArray.length - 1];
            return last;
          }).forEach((o) => this.#addMesssage(o));
          break;
        }
        case "error": {
          this.#addError(data);
          console.error("Error:", data);
          break;
        }
      }
    }
    if (!receivedNext) {
      await this.#concludeChat();
      this.#startChat();
    }
  }

  async #onSendMessage(e: SendMessageEvent) {
    this.#addMesssage(llmContent(e.message, "user"));
    this.#sendRequest(e.message);
  }

  render() {
    return html`
      <div class="header">
        <div id="metadata">
          <h1>${this.title} <a href="https://breadboard-ai.web.app/?board=${this.#url}" target="_blank">board</a></h1>
          <p>${this.description}</p>
        </div>
        <button @click=${this.#clearMessages}>Clear History 🧹</button>
      </div>
      <chat-history .messages=${this.messages} .typing=${this.typing}></chat-history>
      <chat-input .schema=${this.#schema} .waiting=${this.typing} @chatsendmessage=${this.#onSendMessage}></chat-input>
    `;
  }
}

@customElement("chat-history")
export class ChatHistory extends LitElement {
  static styles = css`
    :host {
      flex-grow: 1;
      overflow-y: auto;
      padding: 15px;
      display: flex;
      flex-direction: column-reverse;
      background-image: url("data:image/svg+xml,%3Csvg width='52' height='26' viewBox='0 0 52 26' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%233498db' fill-opacity='0.05'%3E%3Cpath d='M10 10c0-2.21-1.79-4-4-4-3.314 0-6-2.686-6-6h2c0 2.21 1.79 4 4 4 3.314 0 6 2.686 6 6 0 2.21 1.79 4 4 4 3.314 0 6 2.686 6 6 0 2.21 1.79 4 4 4v2c-3.314 0-6-2.686-6-6 0-2.21-1.79-4-4-4-3.314 0-6-2.686-6-6zm25.464-1.95l8.486 8.486-1.414 1.414-8.486-8.486 1.414-1.414z' /%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
    }

    #typing {
      color: gray;
    }

    .dots {
            display: inline-block;
            vertical-align: middle;
        }

    .dots span {
        display: inline-block;
        width: 0.1em;
        height: 0.25em;
        animation: jump 1.5s infinite;
    }

    .dots span:nth-child(2) {
        animation-delay: 0.2s;
    }

    .dots span:nth-child(3) {
        animation-delay: 0.4s;
    }

    @keyframes jump {
        0%, 60%, 100% {
            transform: translateY(0);
        }
        30% {
            transform: translateY(-0.5em);
        }
    }
  `;

  @property()
  accessor messages: Message[] = [];

  @property()
  accessor typing = false;

  updated(changedProperties: Map<string, any>) {
    if (changedProperties.has("messages")) {
      this.scrollTop = this.scrollHeight;
    }
  }

  render() {
    return html`
      ${
      this.typing
        ? html`<div id="typing">Thinking
        <div class="dots">
          <span>.</span>
          <span>.</span>
          <span>.</span>
        </div>
      </div>`
        : nothing
    }
      ${
      this.messages.map((message) =>
        html`<chat-message .message=${message}></chat-message>`
      )
    }`;
  }
}

@customElement("chat-message")
export class ChatMessage extends LitElement {
  static styles = css`
    :host {
      display: flex;
      flex-direction: column;
    }

    #container {
      background-color: #ecf0f1;
      padding: 10px;
      border-radius: 15px 15px 15px 2px;
      margin-bottom: 10px;
      max-width: 80%;
      box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
      transition: all 0.3s cubic-bezier(.25,.8,.25,1);
      display: flex;
      flex-direction: column;
    }
    
    #container:hover {
      box-shadow: 0 14px 28px rgba(0,0,0,0.25), 0 10px 10px rgba(0,0,0,0.22);
    }

    #container.model {
      align-self: flex-start;
    }

    #container.error {
      background-color: var(--ca-color-error);
    }
    
    #container.user {
      border-radius: 15px 15px 2px 15px;
      background-color: var(--ca-color-primary);
      color: var(--ca-color-primary-bg);
      align-self: flex-end;
    }

    p {
      margin: 0;
      padding: 0 0 0.7em 0;
    }

    .timestamp {
      font-size: 0.7em;
      align-self: flex-end;
    }

    img {
      border-radius: 10px;
      box-sizing: border-box;
      width: 100%;
    }
  `;

  @property()
  accessor message: Message | null = null;

  render() {
    if (!this.message) {
      return nothing;
    }
    let content;
    let role;
    if ("error" in this.message) {
      role = "error";
      content = this.message.error;
    } else {
      const { parts } = this.message;
      role = this.message.role;
      content = parts.map((part) => {
        if ("text" in part) {
          return html`${unsafeHTML(markdownIt.render(part.text))}`;
        } else {
          const dataURL =
            `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
          const partDataURL = fetch(dataURL)
            .then((response) => response.blob())
            .then((data) => {
              const url = URL.createObjectURL(data);
              return url;
            });
          return html`<img src="${until(partDataURL)}">`;
        }
      });
    }

    return html`
      <div id="container" class="${role}">
        <div class="content">${content}</div>
        <div class="timestamp">${timeAgo.format(this.message.timestamp)}</div>
      </div>
    `;
  }
}

@customElement("chat-input")
export class ChatInput extends LitElement {
  static styles = css`
    :host {
      display: flex;
      padding: 15px;
      background-color: #ecf0f1;
    }

    form {
      display: flex;
      flex-grow: 1;
      margin: 0;
    }

    input[type=text] {
      flex-grow: 1;
      margin-right: 10px;
      padding: 10px;
      border: 2px solid var(--ca-color-primary-bg);
      border-radius: 20px;
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      font-size: 14px;
    }

    input[type=text]:focus {
      border: 2px solid var(--ca-color-primary);
      outline: none;
    }

    input[type=submit] {
      padding: 10px 15px;
      background-color: var(--ca-color-primary);
      color: var(--ca-color-primary-bg);
      border: 2px solid var(--ca-color-primary);
      border-radius: 20px;
      cursor: pointer;
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      font-size: 14px;
      font-weight: bold;
      transition: all 0.3s cubic-bezier(.25,.8,.25,1);
    }
    input[type=submit]:hover {
      background-color: #2980b9;
      box-shadow: 0 3px 6px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
    }
    input[type=submit]:active {
      transform: scale(0.98);
    }
  `;

  @property()
  accessor waiting = false;

  @property()
  accessor schema: Schema | null = null;

  updated() {
    requestAnimationFrame(() => {
      this.renderRoot.querySelector("input")?.focus();
    });
  }

  #onSendMessage(e: Event) {
    e.preventDefault();
    const input = this.renderRoot.querySelector("input");
    if (input && input.value) {
      this.dispatchEvent(new SendMessageEvent(input.value));
      input.value = "";
    }
  }

  render() {
    if (!this.schema) {
      return nothing;
    }
    const key = Object.keys(this.schema.properties)[0];
    const prop = this.schema.properties[key];
    const placeholder = prop.description || "Type a message to chat";
    return html`
      <form @submit="${this.#onSendMessage}">
      <input type="text" placeholder="${placeholder}" ?disabled=${this.waiting}>
      <input type="submit"value="Send 🤘" ?disabled=${this.waiting}>
      </form>
    `;
  }
}
